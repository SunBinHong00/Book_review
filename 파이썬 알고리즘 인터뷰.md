- big O
  - O(1)
    - 해시 테이블의 조회 및 삽입
    - 입력값이 아무리 커도 실행 시간은 일정
  - O(log n)
    - 이진 검색
    - 로그는 매우 큰 입력값에도 크게 영향을 받지 않는다
  - O(n)
    - 리스트에서 최댓값 또는 최솟값을 찾는 경우
    - 이 값을 찾기 위해서는 모든 입력값을 적어도 한 번이 이상은 살펴봐야 한다.
    - 선형시간 알고리즘
  - O(n log n)
    - 병합정렬을 비롯한 효율 좋은 정렬 알고리즘
    - 비교 기반 정렬 알고리즘은 O(n log n)보다 빠를 수 없다.
    - **팀소트(Timsort)**
  - O(n^2)
    - 버블 정렬같은 비효율적인 정렬 알고리즘
  - O(2^n)
    - 파보나치수를 재귀로 계산하는 알고리즘
  - O(n!)
    - 브루트 포스
    - 외판원 문제(TSP)
      - 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 문제
    - 가장 느린 알고리즘


- 해시 테이블
  - 키를 값에 매핑할수 있는 구조
  - 연관 배열 추상 자료형(ADT)을 구현하는 자료구조

- 해시
  - 임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수
  - 정보를 가능한 한 빠르게 저장하고 검색하기 위해 사용하는 중요한 기법 중 하나
  - 심볼 테이블 등의 자료구조 구현에 적합
  - 체크섬, 손실합축 무자가위화 함수, 암호
  - 성능 좋은 해시 함수들의 특징
    1. 해시 함수 값 충돌의 최소화
    2. 쉽고 빠른 연산
    3. 해시 테이블 전체에 해시 값이 균일하게 분포
    4. 사용할 키의 모든 정보를 이용하여 해싱
    5. 해시 테이블 사용 효율이 높을 것

- 생일 문제
  - 여러 사람이 모였을 때 생일이 같은 2명이 존재할 확률은?
  - 비둘기집 원리
    - n+1개의 물건을 n개의 상자에 넣을 때 적어도 어느 한 상자에는 두 개 이상의 물건이 들어 있다는 원리
  - 좋은 해시 함수라면 충돌을 최소화한다.

- 로드 팩터
  - 해시 테이블에 저장된 데이터 개수 n을 버킷의 개수 k로 나눈 것
  - 이 비율에 따라 해시 함수를 재작성 여부를 결정

- 해시의 충돌
  - 아무리 좋은 해시 함수라도 충돌은 발생한다.
  - 처리 방법
    - 개별 체이닝
      - 중복된 데이터를 연결 리스트로 연결하는 방식
    - 오픈 어드레싱
      - 출돌 발생 시 탐사를 통해 빈 공간을 찾는 방식
      - 반드시 모든 원소가 자신의 해시값과 일치하는 주소에 저장된다는 보장이 없다.
      - 고르게 분포되지 않는다.
      - 버킷 사이즈보다 큰 경우 삽입할 수 없다.
      - 로드 팩터 비율을 넘어서게 되면, 그로스 팩터의 비율에 따라 더 큰 크기의 또 다른 버킷을 생성 후 새롭게 복사하는 리해싱 작업이 일어난다.

- 파이썬으로 해시맵 구현
```python
import collections


# Definition for singly-linked list.
class ListNode:
    def __init__(self, key=None, value=None):
        self.key = key
        self.value = value
        self.next = None


class MyHashMap:
    # 초기화
    def __init__(self):
        self.size = 1000
        self.table = collections.defaultdict(ListNode)

    # 삽입
    def put(self, key: int, value: int) -> None:
        index = key % self.size
        # 인덱스에 노드가 없다면 삽입 후 종료
        if self.table[index].value is None:
            self.table[index] = ListNode(key, value)
            return

        # 인덱스에 노드가 존재하는 경우 연결 리스트 처리
        p = self.table[index]
        while p:
            if p.key == key:
                p.value = value
                return
            if p.next is None:
                break
            p = p.next
        p.next = ListNode(key, value)

    # 조회
    def get(self, key: int) -> int:
        index = key % self.size
        if self.table[index].value is None:
            return -1

        # 노드가 존재할때 일치하는 키 탐색
        p = self.table[index]
        while p:
            if p.key == key:
                return p.value
            p = p.next
        return -1

    # 삭제
    def remove(self, key: int) -> None:
        index = key % self.size
        if self.table[index].value is None:
            return

        # 인덱스의 첫 번째 노드일때 삭제 처리
        p = self.table[index]
        if p.key == key:
            self.table[index] = ListNode() if p.next is None else p.next
            return

        # 연결 리스트 노드 삭제
        prev = p
        while p:
            if p.key == key:
                prev.next = p.next
                return
            prev, p = p, p.next
```

